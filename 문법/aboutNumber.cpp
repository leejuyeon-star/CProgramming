/*
    자료형, 숫자 사용시 주의할 점
    - overflow
*/

//***********************문자 셋 변환하는 방법***************************
// * WBCS(UNICODE) 기반으로 컴파일하고자 하는 경우 "#include보다 위에" 해당 코드 삽입
// * 이 경우 _tmain 불가. main만 가능
// #define UNICODE
// #define _UNICODE

// * MBCS 기반으로 컴파일하고자 하는 경우 아래 코드 삽입
// #undef UNICODE
// #undef _UNICODE
//**************************************************


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>		//동시지원하는 함수를 MBCS, WBCS 함수로 변환해줌. 함수 사용시 이 파일에서 함수 검색.
#include <float.h>    // float의 머신 엡실론 값 FLT_EPSILON이 정의된 헤더 파일
#include <math.h>     // float의 절댓값을 구하는 fabsf()를 위한 헤더 파일
#include <limits.h>     //overflow를 막기 위한 헤더파일

int main(void)
{
    //* 문제 : overflow
    // 원인 : 자료형의 크기를 넘어서 저장. unsigned같은 부호없는 자료형의 경우 오버플로를 감지하지 못함
    // 예방 : 
    //   방법 1) 오버플로우를 완벽히 검사할 수 있는 컴파일러를 사용한다
    //      - c/c++의 경우 
    //   방법 2) 오버플로우를 완벽히 검사할 수 있는 라이브러리를 활용한다   
    //      - c/c++의 경우
        
    //?  방법 3) 오버플로우를 완벽히 검사할 수 있는 함수를 직접 제작한다???
    //      - c/c++의 경우
    
    

    // 2147483647

    int x = 2147483647; 
    // int y = 1;
    int value = x+1;        //단항 연산자는 작동하지 않음
    bool overflow = value < x ;
    _tprintf(_T("%d"), overflow);



    //* 문제 : 컴퓨터에서 표현하는 실수는 오차가 있다.
    // 원인 : 컴퓨터는 무한히 많은 실수를 표현하지 못하기 때문에 입력한 수의 근사치값을 저장하게 된다
    // 예방 : 
    //  방법 1) 등호 대신 부등호 사용 ( '==' 대신 '<=', '>=' 를 사용한다)
    //  방법 2) c/c++의 경우 머신 엡실론 사용
    float num1 = 0.0f;

    if (fabsf(num1 - 0.0f) <= FLT_EPSILON)    // 연산한 값과 비교할 값의 차이를 구하고 절댓값으로
    {                                          // 만든 뒤 FLT_EPSILON보다 작거나 같은지 판단
        printf("true\n");                     // 오차가 머신 엡실론 이하라면 같은 값으로 봄
                                              // 값의 차이가 머신 엡실론보다 작거나 같으므로 true
    } else
    {
        printf("false\n");
    }

    //* 문제 : unsigned와 signed를 비교하는 경우
    

    //* 문제 : 문자가 깨져서 나온다
    //원인 : 컴퓨터 간의 문자 셋이 다르거나 인코딩 방식이 다르기 때문
    //예방 : 
    //  (참고 https://studyforus.tistory.com/167) 
    //  방법 1) 플랫폼이 제공하는 문자 셋으로 코드를 구현하고 인코딩 방식을 똑같이 맞춰준다
    //       - 문자 셋은 표현할 문자들을 표로 나타낸것을 말하고, 인코딩은 문자 셋의 문자 하나하나를 2진수로 변환해주는 것을 말한다

    //       - 문자 셋 종류
    //       MBCS - TCHAR의 크기를 1byte로 설정. 가변길이 방식. 영어는 한글자당 1byte에 넣고, 한글은 한글자당 2byte(EUC-KR)에 또는 3byte(UTF-8)에 넣는다.
    //       WBCS(UNICODE) - TCHAR의 크기를 2byte로 설정. 모든 글자를 2byte에 넣는다.
    // 
    //       - 인코딩 종류
    //       ASCII : 모든 문자를 1byte로 표현
    //       EUC-KR : 완성형 인코딩 방식, 한글을 2byte로 표현, 한글을 사용하는 국가에서만 한글 볼수있음, 한글조합 한정적으로 제공
    //       CP-949 : 완성형 인코딩 방식, 한글을 2byte로 표현, 윈도우에서 개발(EUC-KR에서 진화, 모든 한글조합 제공), 한글을 사용하는 국가에서만 한글 볼 수 있음
    //       UTF-8 : 조합형 인코딩 방식, 가변길이 방식(1~4byte), 한글을 3byte로 표현(초성,중성,종성으로 따로 저장하므로), 
    //                  ASCII문자 표현(1byte)이 가능해 대표적인 UNICODE 인코딩 방식임, 전 세계 글자를 표현할 수 있음
    //       UTF-16 : 조합형 인코딩 방식, 모든 글자를 2byte로 표현, UNICODE 인코딩 방식 중 하나, 전 세계 글자를 표현할 수 있음
    //       
    //       - 한글 표현 가능 관계:
    //              - EUC-KR <- UTF-8 <-> CP-949  (EUC-KR -> UTF-8만 불가능)
    //              - 단, 웹에서는 무조건 인코딩 방식이 같아야 한다

    //  방법 2) 


    return 0;
}
