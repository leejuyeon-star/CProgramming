/*
    자료형, 숫자 사용시 주의할 점
    - overflow
*/

//***********************문자 셋 변환하는 방법***************************
// * WBCS(UNICODE) 기반으로 컴파일하고자 하는 경우 "#include보다 위에" 해당 코드 삽입
// * 이 경우 _tmain 불가. main만 가능
// #define UNICODE
// #define _UNICODE

// * MBCS 기반으로 컴파일하고자 하는 경우 아래 코드 삽입
// #undef UNICODE
// #undef _UNICODE
//**************************************************



#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>		//동시지원하는 함수를 MBCS, WBCS 함수로 변환해줌. 함수 사용시 이 파일에서 함수 검색.
#include <float.h>    // float의 머신 엡실론 값 FLT_EPSILON이 정의된 헤더 파일
#include <math.h>     // float의 절댓값을 구하는 fabsf()를 위한 헤더 파일

int main(void)
{
    //* 문제 : overflow
    // 원인 : 
    //  - 자료형의 크기를 넘어서 저장. unsigned같은 부호없는 자료형의 경우 오버플로를 감지하지 못함
    //  - c/c++의 경우 자료형 별 메모리 크기가 컴파일러마다 약간 다르다. (java는 고정됨)
    // 예방 : 
    //   방법 1) 오버플로우를 완벽히 검사할 수 있는 컴파일러를 사용한다
    //      - c/c++의 경우 
    //   방법 2) 오버플로우를 완벽히 검사할 수 있는 라이브러리를 활용한다   
    //      - c/c++의 경우
        
    //?  방법 3) 오버플로우를 완벽히 검사할 수 있는 함수를 직접 제작한다???
    //      - c/c++의 경우


    //* 문제 : 자료형 선택 방법
    // 해결 : 
    //      -정수의 경우 : - 연산 횟수가 빈번한 경우 CPU가 성능을 내기에 가장 좋은 크기의 자료형을 사용하자. (win32는 32bit)
    //                          - c/c++의 경우 int가 이에 해당
    //                    - 데이터 양이 많아 데이터 크기를 줄이는 것이 중요한 데이터의 경우(음성,영상) 작은 크기의 자료형을 사용하자.
    //                          - c/c++의 경우  char, short가 이에 해당
    //      -실수의 경우 : -  정밀도가 높으면서도 크기가 적당한 자료형을 사용하자. (오차가 발생하지 않는 소수점 이하의 자릿수)
    //                          - c/c++의 경우 보편적으로 double을 사용한다(정밀도 : 15자리)

    //* 문제 : unsigned 관련 문제, 정수형에만 unsigned 붙일수있다는데?
    // 원인 :
    // 해결 :




    //* 문제 : 64bit 기반 기기와 32bit 기반 기기 호환성 문제
    // 예방 : 64bit와 32bit의 차이
    // 의문 : 64bit의 경우 CPU가 처리하기에 가장 적합한 크기는 64bit인가?


    //* 문제 : 상수 저장 관련
    //* 원인 : - c/c++의 경우 상수를 저장할 자료형이 정해져 있다. 정수는 int, 실수는 double이다. 상수의 크기가 더 큰 경우 큰 자료형으로 자동 변경된다
    // 예방 : - c/c++의 경우 접미사를 이용한다


    //* 문제 : 컴퓨터에서 표현하는 실수는 오차가 있다.
    // 원인 : 컴퓨터는 무한히 많은 실수를 표현하지 못하기 때문에 입력한 수의 근사치값을 저장하게 된다
    // 예방 : 
    //  방법 1) 등호 대신 부등호 사용 ( '==' 대신 '<=', '>=' 를 사용한다)
    //  방법 2) c/c++의 경우 머신 엡실론 사용
    //             #include <float.h>    // float의 머신 엡실론 값 FLT_EPSILON이 정의된 헤더 파일
    //             #include <math.h>     // float의 절댓값을 구하는 fabsf()를 위한 헤더 파일
                    float num1 = 0.0f;
                    if (fabsf(num1 - 0.0f) <= FLT_EPSILON)    // 연산한 값과 비교할 값의 차이를 구하고 절댓값으로
                        printf("true\n");                    // 만든 뒤 FLT_EPSILON보다 작거나 같은지 판단
                    else                                     // 오차가 머신 엡실론 이하라면 같은 값으로 봄
                        printf("false\n");                   // 값의 차이가 머신 엡실론보다 작거나 같으므로 true


    //* 문제 : unsigned와 signed를 비교하는 경우
    

    //* 문제 : 문자가 깨져서 나온다
    //원인 : 컴퓨터 간의 문자 셋이 다르거나 인코딩 방식이 다르기 때문
    //예방 : 
    //  (참고 https://studyforus.tistory.com/167) 
    //  방법 1) 플랫폼이 제공하는 문자 셋으로 코드를 구현하고 인코딩 방식을 똑같이 맞춰준다
    //       - 문자 셋은 표현할 문자들을 표로 나타낸것을 말하고, 인코딩은 문자 셋의 문자 하나하나를 2진수로 변환해주는 것을 말한다

    //       - 문자 셋 종류
    //       MBCS - TCHAR의 크기를 1byte로 설정. 가변길이 방식. 영어는 한글자당 1byte에 넣고, 한글은 한글자당 2byte(EUC-KR)에 또는 3byte(UTF-8)에 넣는다.
    //       WBCS(UNICODE) - TCHAR의 크기를 2byte로 설정. 모든 글자를 2byte에 넣는다.
    // 
    //       - 인코딩 종류
    //       ASCII : 모든 문자를 1byte로 표현
    //       EUC-KR : 완성형 인코딩 방식, 한글을 2byte로 표현, 한글을 사용하는 국가에서만 한글 볼수있음, 한글조합 한정적으로 제공
    //       CP-949 : 완성형 인코딩 방식, 한글을 2byte로 표현, 윈도우에서 개발(EUC-KR에서 진화, 모든 한글조합 제공), 한글을 사용하는 국가에서만 한글 볼 수 있음
    //?      UTF-8 : 조합형 인코딩 방식, 가변길이 방식(1~4byte), 한글을 3byte로 표현(초성,중성,종성으로 따로 저장하므로),  WBCS는 모든 글자를 2byte에 넣는데 한글을 3byte로 표현하면 [1]안에 다 안들어가야 하는것 아닌가?
    //                  ASCII문자 표현(1byte)이 가능해 대표적인 UNICODE 인코딩 방식임, 전 세계 글자를 표현할 수 있음
    //       UTF-16 : 조합형 인코딩 방식, 모든 글자를 2byte로 표현, UNICODE 인코딩 방식 중 하나, 전 세계 글자를 표현할 수 있음
    //       
    //       - 한글 표현 가능 관계:
    //              - EUC-KR <- UTF-8 <-> CP-949  (EUC-KR -> UTF-8만 불가능)
    //              - 단, 웹에서는 무조건 인코딩 방식이 같아야 한다

    //  방법 2) 


    //* 문제 : static 함수는 언제 쓰고 언제 쓰지 말아야 하는가?
    // -변수의 경우
    // 기능 : 프로그램이 시작되자마자 메모리 할당되어 초기화됨, 프로그램 종료시까지 소멸되지 않음, 선언된 함수 또는 클래스 내에서만 접근 가능  
    // 장점 : 변수 할당,초기화하는 시간 절약 가능
    // 단점 : 프로그램이 끝날때까지 남아있기 때문에 메모리 효율 떨어짐(java는 예외), 
    
    // -함수/클래스의 경우
    //   - c의 경우(절차지향)
    //      기능 : 그 함수는 해당 소스파일에서만 사용가능하게 함.  
    //      장점 : 다른 파일과의 충돌 가능성 막음(다른 파일과의 중복 함수명 허용), 가독성 증가(이 함수가 어디에서 사용되었는지 헤맬 필요 없어짐)
    //   - c++/c#/java 의 경우(객체지향)
    //      기능 : 인스턴스를 생성하지 않아도 함수 호출을 할 수 있음
    //      장점 : 반복적으로 객체 할당하는 시간을 줄일 수 있음
    //      단점 : 객체지향의 "메세지 전달", "다형성"을 위반. 따라서 인터페이스를 구현할 때는 부적절
    
    // 해결 : unity의 경우 한 프로젝트를 통제하는 클래스에 넣어준다 


    //* 문제 : register 변수는 언제 써야 하는가?
    


    return 0;
}
